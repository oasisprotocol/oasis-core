// This is re-exported here only so it can be used in macros under a common name.
pub use rustracing_jaeger::Tracer;

pub use ekiden_common::bytes::B256;
pub use ekiden_common::environment::Environment;
pub use ekiden_common::futures::{BoxFuture, Future};
pub use ekiden_enclave_common::quote;
pub use ekiden_registry_base::EntityRegistryBackend;
pub use ekiden_roothash_base::backend::RootHashBackend;
pub use ekiden_scheduler_base::Scheduler;
pub use ekiden_storage_base::backend::StorageBackend;

/// Create a runtime client for a given API.
///
/// # Examples
///
/// This macro should be invoked using a concrete API generated by `runtime_api` as
/// follows:
/// ```rust,ignore
/// with_api! {
///     create_runtime_client!(foo, foo_api, api);
/// }
/// ```
///
/// In this example, the generated client will be put into a module called `foo`
/// which will use API structures from module `foo_api`. The API definitions will
/// passed as the last argument as defined by the `api` token.
#[macro_export]
macro_rules! create_runtime_client {
    (
        $output_module: ident,
        $api_module: path,

        $(
            pub fn $method_name: ident ( $request_type: ty ) -> $response_type: ty ;
        )*
    ) => {
        mod $output_module {
            use std::sync::Arc;
            use std::time::Duration;

            use $crate::manager::RuntimeClientManager;
            use $crate::macros::quote::MrEnclave;
            use $crate::macros::*;

            pub use $api_module::*;

            pub struct Client {
                environment: Arc<Environment>,
                storage: Arc<StorageBackend>,
                roothash: Arc<RootHashBackend>,
                manager: RuntimeClientManager,
            }

            #[allow(dead_code)]
            impl Client {
                /// Create new client instance.
                pub fn new(
                    runtime_id: B256,
                    mr_enclave: MrEnclave,
                    timeout: Option<Duration>,
                    environment: Arc<Environment>,
                    scheduler: Arc<Scheduler>,
                    entity_registry: Arc<EntityRegistryBackend>,
                    roothash: Arc<RootHashBackend>,
                    storage: Arc<StorageBackend>,
                ) -> Self {
                    Client {
                        manager: RuntimeClientManager::new(
                            runtime_id,
                            mr_enclave,
                            timeout,
                            environment.clone(),
                            scheduler,
                            entity_registry,
                            roothash.clone(),
                            storage.clone(),
                        ),
                        environment,
                        storage,
                        roothash,
                    }
                }

                /// Return the used Ekiden environment instance.
                pub fn get_environment(&self) -> Arc<Environment> {
                    self.environment.clone()
                }

                /// Return the used Ekiden storage backend instance.
                pub fn get_storage(&self) -> Arc<StorageBackend> {
                    self.storage.clone()
                }

                /// Return the used Ekiden roothash backend instance.
                pub fn get_roothash(&self) -> Arc<RootHashBackend> {
                    self.roothash.clone()
                }

                // Generate methods.
                $(
                    pub fn $method_name(
                        &self,
                        arguments: $request_type
                    ) -> BoxFuture<$response_type> {
                        self.manager.call(stringify!($method_name), arguments)
                    }
                )*
            }
        }
    };
}
